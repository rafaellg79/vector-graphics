//Standard libraries
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

//External libraries
//stb_image_write
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

//Headers
#include "shortcut_tree.h"
#include "util.h"
#include "vec.h"
#include "filter.h"
#include "raster.h"

unsigned int pack(unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    return (a << 24) | (b << 16) | (g << 8) | r;
}

// pack the normalized rgba color values into a 32 bit integer in abgr format
unsigned int pack_vec(vec4 c) {
    unsigned char r = 255 * c.x, g = 255 * c.y, b = 255 * c.z, a = 255 * c.w;
    return pack(r, g, b, a);
}

// Assumes shape->path has enough space to store the curves after implicitization
// It should be enough if shape->path[shape->num_segments + npts] is a valid memory address
void fill_shape(Shape * shape, real * pts, int npts){
    int i, j;
    for (i = 0; i + 3 < npts; i += 3) {
        real curve_pts[8];
        for (j = 0; j < 8; j += 2) {
            curve_pts[j] = pts[i * 2 + j];
            curve_pts[j + 1] = pts[i * 2 + j + 1];
        }
        enum Cubic type = regenerate(curve_pts);
        monotonize(shape, curve_pts, type);
    }
}

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("Usage: %s <output_file>\n", argv[0]);
        return 0;
    }

    int i, j;
    int max_depth = 10, num_samples = 1;
    real pattern[] = {0.0, 0.0};

    real pts[] = { 195.500000,  15.500000, 195.500000,  15.500000,  195.500000, 195.500000, // right line
                   195.500000, 195.500000, 195.500000, 195.500000,   15.500000, 195.500000, // bottom line
                    15.500000, 195.500000,  15.500000, 195.500000,   15.500000,  15.500000, // left line
                    15.500000,  15.500000, 345.500000, 255.500000, -134.500000, 255.500000, // loop
                   195.500000,  15.500000 };
    int npts = 13;

    int width = 210, height = 210;
    unsigned int* image = (unsigned int*)malloc(sizeof(unsigned int) * width * height);

    if (!max_depth) {
        max_depth = fmax(0., ceil(log2(fmax(width, height))));
    }

    int* max_segs = (int*)malloc(sizeof(int) * max_depth);
    int depth;
    for (depth = 0; depth < max_depth; depth++) {
        max_segs[depth] = (int)fmax(1, depth * depth);
    }

    // Tree creation
    ShortcutTree tree;
    tree.shapes = (Shape*)malloc(sizeof(Shape));
    tree.shapes[0].path = (Curve*)malloc(sizeof(Curve) * 16); // Allocate memory for some extra curves generated by implicitization
    tree.size = 1;
    tree.max_depth = max_depth;
    tree.max_segs = max_segs;

    // Create Shape struct to store paint and curves
    Shape* s = tree.shapes;
    Paint paint = {.type = PAINT_COLOR, .opacity = 1.0, .color = {1.0, 0.0, 0.0, 1.0}};
    s->paint = paint;
    s->winding_test = evenodd;
    s->BB = create_BoundingBox(15.5, 15.5, 195.5, 195.5);
    s->num_segments = 0;
    fill_shape(s, pts, npts);
    real cell_size = pow(2., ceil(log2(fmax(height, width))));

    build_tree(&tree, cell_size);

    vec4 white = { 1.0, 1.0, 1.0, 1.0 };

    printf("Rendering...\n");
    for (i = 0; i < height; i++) {
        real y = i + 0.5;
        int j;
        for (j = 0; j < width; j++) {
            real x = j + 0.5;
            image[i * width + j] = pack_vec(supersample(tree.root, pattern, num_samples, x, y, white));
        }
        fprintf(stderr, "\r%.2f%%", 100. * i / height);
    }
    fprintf(stderr, "\r100.00%%");

    printf("Finished rendering.\n");

    printf("Saving to file...\n");

    int error_code = stbi_write_png(argv[1], width, height, 4, (const unsigned char*)image, 0);
    if (error_code == 0) {
        fprintf(stderr, "error: %i\n", error_code);
        return 1;
    }
    printf("File saved successfully.\n");

    free(image);
    delete_tree(&tree);

    return 0;
}